这是一篇关于c语言的教程 大致描述c的常用语法和一些技巧 为了保持精简 我会提供一些搜索的关键词 以保证可以搜索到其他没有讲解的问题 

由于c语言标准有几个 包括但不限于c89 c99 c11 默认情况下 这里讲解c99标准 而c11与c99语法上大致相同 主要注意c89与c99的区别 具体的不同会被指出

另外 为了打字方便 这里统一使用空格分隔句子 不会出现任何标点符号




# 快速入门



快速入门会提到大部分常用的语法 会略去一些细节 只给出一些最常用的语法 应注重程序的编写而不是语言的细节上 



### 编译器 编辑器 集成开发环境

这是编写程序的必要准备 编写程序的过程中 我们需要编辑器 其中 你可以选择一款自己喜欢的编辑器 比如 Sublime 或者NotePad++ 以及其他的编辑器

编写好的程序 我们需要编译器将代码翻译成机器语言 这里 只使用 gcc 

由于gcc是linux的编译器 linux系统一般自带gcc 而windows上运行gcc 可以下载TDM64 

或者Mingw-w64 搜索之后下载即可

集成开发环境[IDE] 是既可以编辑也可以编译的软件 比如 Codeblocks ,Visual Studio ,Eclipse

由于是c语言的编写 推荐codeblocks 



由于集成开发环境直接使用比较简单 这里不介绍如何使用 只讲如何用gcc编译编写的代码

linux下直接打开bash 输入

`gcc test.c `

这样会产生一个a.out的可执行文件 运行只需输入

`./a.out`

windows下的cmd并不好用 而cygwin过于庞大 可以使用较小的 git bash for windows 本身是给git使用的 不过编译c语言绰绰有余

打开git bash后 输入和linux下相同 这是生成的文件是a.exe 因为windows下 可执行文件的后缀必须是.exe 而linux并无限制 运行方式同linux下相同

`./a.exe`

如果想指定生成的可执行文件的名字 可以输入

`gcc test.c -o yourname.exe`

通过-o指定生成的名字

 关于gcc的使用方式 可以参考相关博客 这里有一个[常用的gcc编译选项整理](https://github.com/YohnWang/documents/blob/master/gcc%E5%B8%B8%E7%94%A8%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9.pdf)



### c程序的基本结构

一个最小的c程序 是这样的

```c
int main()
{

}
```

main函数是一个程序的入口 int是main函数的返回值 该返回值是返回给操作系统的 一般返回0表示程序正常运行 如果不指定返回值 默认返回0 如上例程序就是用默认返回值

这个程序什么都干不了 我们让程序输出一段话 显示在终端上 

```c
#include<stdio.h>
int main()
{
    printf("Hello World\n");
}
```

`#include<stdio.h>` 表示包含一个头文件 其中 std是standard的缩写 表示标准 io表示输入输出

包含该头文件是因为使用了printf用于输出`Hello World\n`

其中" "括起来的部分被称为字符串  \n表示换行

注意 c语言的一条语句需要用`;`结尾



### 基本的数据表示

一个程序至少要能计算 而计算就需要数 c语言提供了一些数据类型用于表示数据

char 用于表示字符

int    用于表示整数 [注意是有范围的 现代的PC机上大致是-20亿到+20亿之间 具体的范围后序讲解]

double 用于表示浮点数[并不是小数 是一种对小数的近似的表示 并不精确 注意整数是精确的]

有了数据后 我们便可以进行一些数值计算了 

```c
#include<stdio.h>
int main()
{
    int a=10,b=20;
    printf("a+b=%d\n",a+b);
}
```

`int a=10,b=20;`表示定义两个int型的变量 名字为a和b  并分别初始化为10和20

最后输出a+b的值 `%d`表示输出的是int类型 

浮点数的使用 与int类型相似 只是输出的时候用`%f`代替`%d`

注意 二者不能相互代替 是什么类型就要对应相应的符号

字符类型需要使用`%c`表示 

`char c='A';` 我们要输出c 则`printf("%c",c);`这样终端上会显示一个A

' '用于将相应的字符转码 注意 ' '之间只能存放一个字符 多个字符需要使用字符串 后序讲解



### 程序的控制结构

理论和实践证明，无论多复杂的算法均可通过顺序、选择、循环3种基本控制结构构造出来。

c语言最基本的执行顺序就是从一个函数开始自上而下地顺序执行 

循环语句可以控制一个语句或语句块执行若干次

而选择语句可以控制一个语句或语句块是否执行

在循环语句和选择语句中 必须判断某条件是否成立 

c语言中条件成立使用**非0**表示 条件不成立使用**0**表示

#### 循环

暴力求解是计算机最擅长做的事情 他的计算速度极快 例如 我们考虑一下高斯小学遇到的问题

1+2+3+...+100=？

利用for循环可以很容地编写这个式子

```c
#include<stdio.h>
int main()
{
    int sum=0;
    for(int i=1;i<=100;i++)
        sum=sum+i;
    printf("sum=%d\n",sum);
}
```

定义一个sum用于保存求和结果 for循环的形式是

`for(exp1;exp2;exp3) `

进入for循环首先执行exp1 之后将不再执行 然后执行exp2 此处一般放置条件判断 如果条件成立 则执行for循环下面的语句 执行完成后 会执行exp3 此处i++表示对i自增1 相当于`i=i+1` 之后再执行exp2以确定是否继续执行循环

注意`sum=sum+i`此处的`=`是赋值 注意与初始化区别开来 只有在定义的时候的`=`是初始化 初始化会与赋值有一些区别 具体细节后序描述

另外 `=`表示的是赋值 而不是数学中的相等 相当于把`=`右侧的计算结果赋值给左侧 

所以不能写成`sum+i=sum` 这样会编译错误 

能写在`=`左侧的值叫做左值 



另一个循环表达式是`while`

```c
#include<stdio.h>
int main()
{
    int sum=0;
    int now=1;
    while(now<=100)
    {
        sum+=now;
        now++;
    }
    printf("sum=%d\n",sum);
}
```

他比for的形式更为简单 `while(exp)`  

只要exp的求值结果不为0 就会一直执行下面的语句块

用`{}`括起来的叫做语句块 这里有两条语句[有几个分号就有几条语句] 所以必须使用`{}`

否则 只能像上例的for 后面只能接一条语句[即一个`;`]



下面看一个用`while`循环计算最大公约数的例子

由欧几里得辗转相除法公式 

函数 gcd(a,b)可以计算a和b的最大公约数

其中 gcd(a,b)=gcd(b,a%b) 并且gcd(a,0)=a  [其中`%`在c语言中表示求模 即取余数 如 10%3=1]

由以上公式和性质 我们可以把问题迭代至最后一个公式以化简问题的复杂度

```c
#include<stdio.h>
#include<stdlib.h>

int main(int argc,char *argv[])
{
    int a=15,b=10;
    while(b!=0)
    {
        int c=a%b;
        a=b;
        b=c;
    }
    printf("%d",a);
}
```

在求完`a%b`之后 需要把原来的`a`设置成`b`  再把`b` 设置成`a%b`

其中 `!=` 代表不等于 如果不相等成立 则会返回一个非0值 表示循环可以继续 [`!`和`=`必须紧挨在一起 是一个整体]

如果要表示相等 则用`==` 也是紧挨在一起的 [一个`=`表示赋值或初始化 它会修改位于它左侧变量的值]



#### 条件判断

实际情况中 往往有一些在某一条件成立下 才执行的动作 比如求一个数的绝对值

如果这个数大于0 则不作任何动作 而小于0 需要求他的相反数

```c
#include<stdio.h>
int main()
{
    int a=-10;
    if(a<0)
        a=-a;
    printf("%d\n",a);
}
```

考虑一个更复杂的问题 一些学校往往会根据成绩划分等地 那么该怎么做呢

```c
#include<stdio.h>
int main()
{
    int score=89;
    if(score<60)
        printf("failed\n");
    else if(score<70)
        printf("pass\n");
    else if(score<80)
        printf("mean\n");
    else if(score<90)
        printf("nice\n");
    else
        printf("excellent\n");
}
```

通过`if` `else if` `else` 可以组合成一系列的判断 其中一个成立 那么就不再执行剩余的 注意 执行顺序是从上至下的 如果条件比较简单`else if`不是必须的



### 自定义函数

c语言允许自定义的函数 可以很方便的调用 例如 输出调用`printf`一样

一个函数的结构是这样的 

```
返回类型 自定义函数名(参数列表)
{
    执行相关动作  
}
```



看一个具体的例子 这个函数计算(x+y)*(x-y)

```c
int fun(int x,int y)
{
    return (x+y)*(x-y);
}
```

函数定义之后 如何调用他呢

```c
#include<stdio.h>

int fun(int x,int y)
{
    return (x+y)*(x-y);
}

int main()
{
    int a=20,b=10;
    int result=fun(a,b);
    printf("%d",result);
}
```

注意参数一一对应

有一个值得注意的地方是 **c语言的函数只有值传递 即换入函数的参数都是一份副本 对副本的改变不会影响到原来的变量**

另外 c语言的函数比数学的函数功能更多一点 他不仅可以返回一个值 还可以执行一些动作 但这些需要其他的一些东西 



### 指针

c语言的指针是一种复合类型 这种类型的变量本身也保存一个值 他保存的值是一个内存的地址

内存的编址一般以8个bit为一个单位 称为一个字节 

每一个字节都有一个唯一的地址 就像班级的每一个学生都有一个唯一的学号

指针的形式如下

```c
int a=20,b=10;
int *ptr1=&a,*ptr2=&b;
```

`int *`表示一个指向int类型的指针 这里注意ptr2前面也有`*`这是因为指针是复合类型 所以必须再写一次 a之前的&表示获取a的首地址 

`ptr1`与`ptr2`存储的是`a`和`b`的地址 那么如何获取到他们存储的值呢

```c
#include<stdio.h>

int main()
{
    int a=20,b=10;
    int *ptr1=&a,*ptr2=&b;
    printf("a=%d b=%d",*ptr1,*ptr2);
}
```

只需在指针变量名字之前加上`*` 即可获取到他们的

是访问指针指向的内容之前 指针必须初始化为或被赋予合法的地址 合法的地址即程序可用的地址 包括变量的地址 申请的内存的地址 合法地址之外的地址的访问 往往会导致程序出错或崩溃

由于变量存储的位置是不变的 即地址不变 那么只需传递给函数他们的地址 就能在另一个函数中修改调用者的变量 

例如 现在要交换a和b的值

```c
#include<stdio.h>

void swap(int *a,int *b)
{
    int tmp=*a;
    *a=*b;
    *b=tmp;
}

int main()
{
    int a=20,b=10;
    printf("%d %d\n",a,b);
    swap(&a,&b);
    printf("%d %d\n",a,b);  
}
```

`void`表示函数不返回任何值

这里主函数也没有显式地返回任何值 但是主函数比较特殊 不标明返回何值 则默认返回0

这是其他函数所没有的

一定要注意的是 **指针必须指向类型一致的对象** `int*`的指针对象必须指向`int`  否则 不保证程序正确性



### 数组

有时候 需要使用大量的同一类型的变量 不可能一个一个地定义 这时候就可以使用数组

数组表示一组同一类型的变量  形式如下

`int arr[1024];`这样 就定义了一个长度为1024的`int`类型数组

数组的下标从`0`开始 所以不能使用`a[1024]` 这样就越界了 即访问了不合法的地址空间

假设现在有一组数据 需要输入 之后按递增顺序输出

```c
#include<stdio.h>

void swap(int *a,int *b)
{
    int tmp=*a;
    *a=*b;
    *b=tmp;
}

int find_min(int a[],int begin,int end)
{
    int min=begin;
    for(int i=begin+1;i<=end;i++)
    {
        if(a[min]>a[i])
            min=i;
    }
    return min;
}

void select_sort(int a[],int n)
{
    for(int i=0;i<n;i++)
    {
        int index=find_min(a,i,n-1);
        swap(&a[i],&a[index]);
    }
}

int main()
{
    int a[1024];
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        scanf("%d",&a[i]);
    select_sort(a,n);
    for(int i=0;i<n;i++)
        printf("%d ",a[i]);
}
```

这是一个简单的选择排序 每一次都找到未排序部分的最小值 然后把他放在第一个

`scanf`表示输入 形式上与`printf`类似 稍微有一点区别 %d表示输入的是int类型的数

注意 由于传入函数的参数都是副本 所以只能传入地址来修改本地的值 所以`scanf`里的参数需要`&`



c语言没有内置的字符串类型 所以只能通过字符数组表示

```c
#include<stdio.h>

int main()
{
    char str[1024]="this is a string\n";
    printf("%s",str);
}
```

字符数组的空间有限 如果字符个数超出字符数组长度再减去1 那么会发生错误

字符数组使用`'\0'`表示字符串结束  所以存储空间会占用掉一个

`"this is a string\n"`可以被称为字符串 不过他是只读的 不可修改 同样 他也是以`'\0'`结束



```c
int main()
{
    char str[1024];
    str="this is a string\n";
    printf("%s",str);
}
```

str是一个字符数组 但是由于初始化和赋值的区别 上述代码是**错误**的 



### 结构体

数组表示了一类相同类型的集合 实际情况中 往往还有一些不同类型的信息集合 

例如 一个学生的信息 一般有 名字 学号 成绩

这类由不同数据类型结合起来的集合可以由结构体表示

```c
#include<stdio.h>

struct student
{
    char name[20];
    int id;
    int score;
};

int main()
{
    struct student John={"John",17,85};
    struct student Lee={.id=10,.name="Lee",.score=89};
    printf("%s id:%d\n",John.name,John.id);
    printf("%s id:%d\n",Lee.name,Lee.id);
}
```

`struct`关键字表示结构体 用于定义一个结构体 注意 结尾有个`;`

在定义完类型后 可以使用`struct student`定义一个变量 

上例中分别使用了两种初始化 第一种需要一一对应 第二种可以指定初始化

注意 只有初始化才能写成如上两种形式 

赋值时不可使用 但可以这么写

`Jack=(struct student){"Jack",9,84};`

`=`右边的部分为一个`struct student`类型的临时变量 将他赋值给Jack

`struct`关键字必须出现在 `student`之前 不可省略 

但可以使用`typedef`来定义一个别名

`typedef struct student stu;`

这样 之后可以用`stu`来定义 

例如`stu Pikachu`

在访问结构体内部的变量是 使用`.`来指定具体的内容





# 基本数据类型

c语言的基本数据类型分为整型和浮点型 整型表示整数 浮点数用于近似表示小数

整型又分为有符号和无符号 有符号整型的类型大致如下

1. `signed char`
2. `short` 
3. `int`
4. `long`
5. `long long`

以上只有`char`前面必须加`signed`关键字才能表示有符号 其余不加默认为有符号

[虽然这很奇怪 但是标准并没有规定`char`是有符号还是无符号 不过大部分编译器都实现为有符号]

另外 `short` `long` `long long `三个关键字后面都可以加`int` 也可以省略不写 就像上面的表一样

例如 `long long int`

下面给出无符号整型 无符号整型前面必须有`unsigned`关键字

1. `unsigned char`
2. `unsigned short`
3. `unsigned int`
4. `unsigned long`
5. `unsigned long long`

尽量不使用无符号类型运算 如果对无符号数的规则不是很清楚 使用无符号数容易出错

在大部分情况下 应使用有符号数 [java语言没有无符号数 这不妨碍他是最受欢迎的语言之一]



为什么c语言使用这么多类型来表示整数呢 一个原因是机器运算时 都是固定位数的二进制运算 这有利于计算速度的提升 而c语言本省 就是对机器的简单抽象 基本上 c语言能做的事 和机器基本相同

这么多类型 表示的数值范围是不一样的 关于c语言标准的描述 这里不进行描述 因为c标准并没有具体规定数值的范围 甚至没有规定应该使用补码 反码或者是其他编码 [这部分内容参考计算机组成原理或者数字电路]

由于大部分机器都使用补码 所以这里直接给出常用的**数据模型**

Data Type     ILP32      ILP64     LP64      LLP64

char                 8               8            8            8

short             16             16          16          16

int                  32             64          32          32

long               32             64          64          32

long long      64             64          64          64

pointer          32             64          64          64

表格中给出的是各类型占用的二进制位数 pointer是指针类型

一般情况下 windows系统与linux系统32位编译器使用ILP32数据模型

如果是64位的编译器 那么windows使用LLP64模型 linux系统使用LP64模型

[编译器位数指的是编译器生成的可执行文件的位数 不是编译程序本身的位数]

**如果对二进制的数据表示不清楚 可查阅相关博客或资料**



小数的表示有以下几种类型

1. `float`
2. `double`
3. `long double`

其中 `float`使用32位二进制表示 `double`使用64位二进制表示 `long double`由具体实现而定

一般来说 最常用的是`double`他的有效数字在15位左右[十进制下的有效数字]

`float`的有效数字较少 大概是6位左右 一般情况下 除非有存储限制 应使用`double`

`long double`基本上不使用 这里只做介绍

一个值得注意的问题是 浮点数是不精确的 例如

```c
int main()
{
    float x,y;
    x=123456789;
    y=123456788;
    printf("%f",x-y);
}
```

上例中 输出结果基本上不为正确的1 因为`float`的有效数字在6位左右 而上例中数字达到9位

如果使用`double`那么结果就没有问题 

由于这个特性 计算顺序有时候也会影响最后的计算结果 



运算过程中的数据类型与类型提升

不同数据类型之间运算时 有一定的规则

1. 不足`int`的 如`char` `short` 等 提升为`int` 
2. 不小于`int`且位数相同的有符号与无符号计算 有符号提升为无符号
3. 短的整型与长的整型计算 短的提升为长的
4. 整型与浮点型计算 整型会提升为浮点型
5. `float`与`double`计算 `float`提升为`double`

注意有符号向无符号转的问题 这也是无符号经常带来的问题 例如

```c
int main()
{
    int x=-1;
    unsigned int y=5;
    printf("%d",y>x);
}
```

正常情况下 y>x 是直觉上正确的 按c的规则 应返回一个非0值 然而 实际输出却是0 原因在于`int`会被提升为`unsigned int` 即-1的补码会被解释成原码[原码用于表示无符号数] 导致x被机器认为是一个很大的数



c语言还有一个基本类型 `void` 但他不能单独使用 必须作为复合类型的一部分或者是函数返回值



# 声明、定义与作用域

由于历史原因 c语言的一个名字[包括变量名 函数名 结构体名等]在使用前 必须在前面声明

一般情况下 定义了一个名字后 在后面即可使用它 即定义的时候会同时表示声明

定义表示的是从无到有地创建了一个名字 前面所有的例子中 都有大量的定义 例如 定义了一个int类型的变量 或者是定义一个函数 他与声明是不同的 声明并不创建新的名字





作用域是表示一个名字在哪里有效 出了作用域的范围 那么这个名字将不再有效

c语言分为**局部作用域**和**全局作用域** 

全局作用域是指定义在所有函数之外 所有结构体之外的变量 [形式上说 是没有在`{}`内部的变量]

局部作用域是指定义在函数内部的变量 [形式上说是定义在`{}`内部的变量]

文字说明不够直观 这里直接给出例子

```c
#include<stdio.h>

int x=10; //全局作用域

int main()
{
    printf("x=%d\n",x);
    int x=0; //局部变量隐藏全局变量
    printf("x=%d\n",x);
    {
        int x=20; //局部变量隐藏上一个局部变量
        printf("x=%d\n",x);
    }
}
```

`//`表示注释 只能注释一行 

`/**/`表示多行注释 注释范围从第一个`/*`开始 直到遇到第一个`*/`结束 注意并不允许嵌套

注释是在预处理阶段进行的 并不发生在编译期

作用域也不仅仅是由`{}`决定的 例如

```c
int fun(int x)
{
    int x=10; //wrong!
    return x+1;
}
```

上例会引发一个重名的编译错误 因为这两个x的作用域是相同的

另一个例子就是`for`

`for(int i=0;i<n;i++){}`中的`i`的作用域与`{}`内相同





定义变量时可以选择是否初始化 如果不进行初始化 局部变量和全局变量会有区别

全局变量会进行默认初始化[c语言中一般就是所有位为0] 局部变量则不进行任何操作

```c
int x; //默认初始化 值为0

void fun()
{
    int x; //不初始化 值不确定
    int y=20; //指定初始化 值为20
}
```



以上结果似乎并没有显示出声明有什么用处 因为定义的时候即已经声明了 下面给出必须使用声明的例子

```c
#include<stdio.h>

extern int add(int x,int y); //声明有add()这个函数

int main()
{
    int x=add(10,20);
    printf("%d",x);
}

int add(int x,int y)
{
    return x+y;
}
```

在main函数中 使用了add()函数 但此时add并没有定义 所有在此之前 必须说明有这个函数

`extern`关键字表示外部的 他可以引用其他文件中的全局变量 

对函数的声明`extern`关键字是可以省略的 但对全局变量的声明 他是不可省略的 否则会被当成是定义变量 从而导致重名错误

[这里提一下 c语言有个历史问题 如果一个函数在使用前没有定义或声明 那么编译器会自动生成一个声明形式为`int function_name()`的声明 所以上例其实是可以编译通过的 但会有警告 不过 不是所有的函数的形式都是如此 如果对应不上 会引发一些程序正确性的错误 `()`内空表示可以接受任意个参数 这也是一个比较容易出错的问题]



变量和函数的声明与定义还可以添加一些修饰前缀

例如 需要使用一个不能被修改的量 使用`const`修饰 `const`原来是常量的意思 但在c语言中准确地说他是**只读[即 read-only]** 

```c
#include<stdio.h>

int add(const int x,const int y)
{
    x=10; //wrong
    return x+y;
}

int main()
{
    const int x=100;
    int z=add(x,20);
    printf("%d",x);
}
```

`const` 更多地是用在指针类型上 后序再介绍 不过定义一个全局的const变量还是很有用的