这是一篇关于c语言的教程 大致描述c的常用语法和一些技巧 为了保持精简 我会提供一些搜索的关键词 以保证可以搜索到其他没有讲解的问题 

由于c语言标准有几个 包括但不限于c89 c99 c11 默认情况下 这里讲解c99标准 而c11与c99语法上大致相同 主要注意c89与c99的区别 具体的不同会被指出

另外 为了打字方便 这里统一使用空格分隔句子 不会出现任何标点符号




# 快速入门



快速入门会提到大部分常用的语法 会略去一些细节 只给出一些最常用的语法 应注重程序的编写而不是语言的细节上 



### 编译器 编辑器 集成开发环境

这是编写程序的必要准备 编写程序的过程中 我们需要编辑器 其中 你可以选择一款自己喜欢的编辑器 比如 Sublime 或者NotePad++ 以及其他的编辑器

编写好的程序 我们需要编译器将代码翻译成机器语言 这里 只使用 gcc 

由于gcc是linux的编译器 linux系统一般自带gcc 而windows上运行gcc 可以下载TDM64 

或者Mingw-w64 搜索之后下载即可

集成开发环境[IDE] 是既可以编辑也可以编译的软件 比如 Codeblocks ,Visual Studio ,Eclipse

由于是c语言的编写 推荐codeblocks 



由于集成开发环境直接使用比较简单 这里不介绍如何使用 只讲如何用gcc编译编写的代码

linux下直接打开bash 输入

`gcc test.c `

这样会产生一个a.out的可执行文件 运行只需输入

`./a.out`

windows下的cmd并不好用 而cygwin过于庞大 可以使用较小的 git bash for windows 本身是给git使用的 不过编译c语言绰绰有余

打开git bash后 输入和linux下相同 这是生成的文件是a.exe 因为windows下 可执行文件的后缀必须是.exe 而linux并无限制 运行方式同linux下相同

`./a.exe`

如果想指定生成的可执行文件的名字 可以输入

`gcc test.c -o yourname.exe`

通过-o指定生成的名字

 关于gcc的使用方式 可以参考相关博客 这里有一个[常用的gcc编译选项整理](https://github.com/YohnWang/documents/blob/master/gcc%E5%B8%B8%E7%94%A8%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9.pdf)



### c程序的基本结构

一个最小的c程序 是这样的

```c
int main()
{

}
```

main函数是一个程序的入口 int是main函数的返回值 该返回值是返回给操作系统的 一般返回0表示程序正常运行 如果不指定返回值 默认返回0 如上例程序就是用默认返回值

这个程序什么都干不了 我们让程序输出一段话 显示在终端上 

```c
#include<stdio.h>
int main()
{
    printf("Hello World\n");
}
```

`#include<stdio.h>` 表示包含一个头文件 其中 std是standard的缩写 表示标准 io表示输入输出

包含该头文件是因为使用了printf用于输出`Hello World\n`

其中" "括起来的部分被称为字符串  \n表示换行

注意 c语言的一条语句需要用`;`结尾



### 基本的数据表示

一个程序至少要能计算 而计算就需要数 c语言提供了一些数据类型用于表示数据

char 用于表示字符

int    用于表示整数 [注意是有范围的 现代的PC机上大致是-20亿到+20亿之间 具体的范围后序讲解]

double 用于表示浮点数[并不是小数 是一种对小数的近似的表示 并不精确 注意整数是精确的]

有了数据后 我们便可以进行一些数值计算了 

```c
#include<stdio.h>
int main()
{
    int a=10,b=20;
    printf("a+b=%d\n",a+b);
}
```

`int a=10,b=20;`表示定义两个int型的变量 名字为a和b  并分别初始化为10和20

最后输出a+b的值 `%d`表示输出的是int类型 

浮点数的使用 与int类型相似 只是输出的时候用`%f`代替`%d`

注意 二者不能相互代替 是什么类型就要对应相应的符号

字符类型需要使用`%c`表示 

`char c='A';` 我们要输出c 则`printf("%c",c);`这样终端上会显示一个A

' '用于将相应的字符转码 注意 ' '之间只能存放一个字符 多个字符需要使用字符串 后序讲解



### 程序的控制结构

理论和实践证明，无论多复杂的算法均可通过顺序、选择、循环3种基本控制结构构造出来。

c语言最基本的执行顺序就是从一个函数开始自上而下地顺序执行 

循环语句可以控制一个语句或语句块执行若干次

而选择语句可以控制一个语句或语句块是否执行

在循环语句和选择语句中 必须判断某条件是否成立 

c语言中条件成立使用**非0**表示 条件不成立使用**0**表示

#### 循环

暴力求解是计算机最擅长做的事情 他的计算速度极快 例如 我们考虑一下高斯小学遇到的问题

1+2+3+...+100=？

利用for循环可以很容地编写这个式子

```c
#include<stdio.h>
int main()
{
    int sum=0;
    for(int i=1;i<=100;i++)
        sum=sum+i;
    printf("sum=%d\n",sum);
}
```

定义一个sum用于保存求和结果 for循环的形式是

`for(exp1;exp2;exp3) `

进入for循环首先执行exp1 之后将不再执行 然后执行exp2 此处一般放置条件判断 如果条件成立 则执行for循环下面的语句 执行完成后 会执行exp3 此处i++表示对i自增1 相当于`i=i+1` 之后再执行exp2以确定是否继续执行循环

注意`sum=sum+i`此处的`=`是赋值 注意与初始化区别开来 只有在定义的时候的`=`是初始化 初始化会与赋值有一些区别 具体细节后序描述

另外 `=`表示的是赋值 而不是数学中的相等 相当于把`=`右侧的计算结果赋值给左侧 

所以不能写成`sum+i=sum` 这样会编译错误 

能写在`=`左侧的值叫做左值 



另一个循环表达式是`while`

```c
#include<stdio.h>
int main()
{
    int sum=0;
    int now=1;
    while(now<=100)
    {
        sum+=now;
        now++;
    }
    printf("sum=%d\n",sum);
}
```

他比for的形式更为简单 `while(exp)`  

只要exp的求值结果不为0 就会一直执行下面的语句块

用`{}`括起来的叫做语句块 这里有两条语句[有几个分号就有几条语句] 所以必须使用`{}`

否则 只能像上例的for 后面只能接一条语句[即一个`;`]



下面看一个用`while`循环计算最大公约数的例子

由欧几里得辗转相除法公式 

函数 gcd(a,b)可以计算a和b的最大公约数

其中 gcd(a,b)=gcd(b,a%b) 并且gcd(a,0)=a  [其中`%`在c语言中表示求模 即取余数 如 10%3=1]

由以上公式和性质 我们可以把问题迭代至最后一个公式以化简问题的复杂度

```c
#include<stdio.h>
#include<stdlib.h>

int main(int argc,char *argv[])
{
    int a=15,b=10;
    while(b!=0)
    {
        int c=a%b;
        a=b;
        b=c;
    }
    printf("%d",a);
}
```

在求完`a%b`之后 需要把原来的`a`设置成`b`  再把`b` 设置成`a%b`

其中 `!=` 代表不等于 如果不相等成立 则会返回一个非0值 表示循环可以继续 [`!`和`=`必须紧挨在一起 是一个整体]

如果要表示相等 则用`==` 也是紧挨在一起的 [一个`=`表示赋值或初始化 它会修改位于它左侧变量的值]



#### 条件判断

实际情况中 往往有一些在某一条件成立下 才执行的动作 比如求一个数的绝对值

如果这个数大于0 则不作任何动作 而小于0 需要求他的相反数

```c
#include<stdio.h>
int main()
{
    int a=-10;
    if(a<0)
        a=-a;
    printf("%d\n",a);
}
```

考虑一个更复杂的问题 一些学校往往会根据成绩划分等地 那么该怎么做呢

```c
#include<stdio.h>
int main()
{
    int score=89;
    if(score<60)
        printf("failed\n");
    else if(score<70)
        printf("pass\n");
    else if(score<80)
        printf("mean\n");
    else if(score<90)
        printf("nice\n");
    else
        printf("excellent\n");
}
```

通过`if` `else if` `else` 可以组合成一系列的判断 其中一个成立 那么就不再执行剩余的 注意 执行顺序是从上至下的 如果条件比较简单`else if`不是必须的



### 自定义函数

c语言允许自定义的函数 可以很方便的调用 例如 输出调用`printf`一样

一个函数的结构是这样的 

```
返回类型 自定义函数名(参数列表)
{
    执行相关动作  
}
```



看一个具体的例子 这个函数计算(x+y)*(x-y)

```c
int fun(int x,int y)
{
    return (x+y)*(x-y);
}
```

函数定义之后 如何调用他呢

```c
#include<stdio.h>

int fun(int x,int y)
{
    return (x+y)*(x-y);
}

int main()
{
    int a=20,b=10;
    int result=fun(a,b);
    printf("%d",result);
}
```

注意参数一一对应

有一个值得注意的地方是 **c语言的函数只有值传递 即换入函数的参数都是一份副本 对副本的改变不会影响到原来的变量**

另外 c语言的函数比数学的函数功能更多一点 他不仅可以返回一个值 还可以执行一些动作 但这些需要其他的一些东西 



### 指针

c语言的指针是一种复合类型 这种类型的变量本身也保存一个值 他保存的值是一个内存的地址

内存的编址一般以8个bit为一个单位 称为一个字节 

每一个字节都有一个唯一的地址 就像班级的每一个学生都有一个唯一的学号

指针的形式如下

```c
int a=20,b=10;
int *ptr1=&a,*ptr2=&b;
```

`int *`表示一个指向int类型的指针 这里注意ptr2前面也有`*`这是因为指针是复合类型 所以必须再写一次 a之前的&表示获取a的首地址 

`ptr1`与`ptr2`存储的是`a`和`b`的地址 那么如何获取到他们存储的值呢

```c
#include<stdio.h>

int main()
{
    int a=20,b=10;
    int *ptr1=&a,*ptr2=&b;
    printf("a=%d b=%d",*ptr1,*ptr2);
}
```

只需在指针变量名字之前加上`*` 即可获取到他们的

是访问指针指向的内容之前 指针必须初始化为或被赋予合法的地址 合法的地址即程序可用的地址 包括变量的地址 申请的内存的地址 合法地址之外的地址的访问 往往会导致程序出错或崩溃

由于变量存储的位置是不变的 即地址不变 那么只需传递给函数他们的地址 就能在另一个函数中修改调用者的变量 

例如 现在要交换a和b的值

```c
#include<stdio.h>

void swap(int *a,int *b)
{
    int tmp=*a;
    *a=*b;
    *b=tmp;
}

int main()
{
    int a=20,b=10;
    printf("%d %d\n",a,b);
    swap(&a,&b);
    printf("%d %d\n",a,b);  
}
```

`void`表示函数不返回任何值

这里主函数也没有显式地返回任何值 但是主函数比较特殊 不标明返回何值 则默认返回0

这是其他函数所没有的

一定要注意的是 **指针必须指向类型一致的对象** `int*`的指针对象必须指向`int`  否则 不保证程序正确性



### 数组

有时候 需要使用大量的同一类型的变量 不可能一个一个地定义 这时候就可以使用数组

数组表示一组同一类型的变量  形式如下

`int arr[1024];`这样 就定义了一个长度为1024的`int`类型数组

数组的下标从`0`开始 所以不能使用`a[1024]` 这样就越界了 即访问了不合法的地址空间

假设现在有一组数据 需要输入 之后按递增顺序输出

```c
#include<stdio.h>

void swap(int *a,int *b)
{
    int tmp=*a;
    *a=*b;
    *b=tmp;
}

int find_min(int a[],int begin,int end)
{
    int min=begin;
    for(int i=begin+1;i<=end;i++)
    {
        if(a[min]>a[i])
            min=i;
    }
    return min;
}

void select_sort(int a[],int n)
{
    for(int i=0;i<n;i++)
    {
        int index=find_min(a,i,n-1);
        swap(&a[i],&a[index]);
    }
}

int main()
{
    int a[1024];
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        scanf("%d",&a[i]);
    select_sort(a,n);
    for(int i=0;i<n;i++)
        printf("%d ",a[i]);
}
```

这是一个简单的选择排序 每一次都找到未排序部分的最小值 然后把他放在第一个

`scanf`表示输入 形式上与`printf`类似 稍微有一点区别 %d表示输入的是int类型的数

注意 由于传入函数的参数都是副本 所以只能传入地址来修改本地的值 所以`scanf`里的参数需要`&`



c语言没有内置的字符串类型 所以只能通过字符数组表示

```c
#include<stdio.h>

int main()
{
    char str[1024]="this is a string\n";
    printf("%s",str);
}
```

字符数组的空间有限 如果字符个数超出字符数组长度再减去1 那么会发生错误

字符数组使用`'\0'`表示字符串结束  所以存储空间会占用掉一个

`"this is a string\n"`可以被称为字符串 不过他是只读的 不可修改 同样 他也是以`'\0'`结束



```c
int main()
{
    char str[1024];
    str="this is a string\n";
    printf("%s",str);
}
```

str是一个字符数组 但是由于初始化和赋值的区别 上述代码是**错误**的 



### 结构体

数组表示了一类相同类型的集合 实际情况中 往往还有一些不同类型的信息集合 

例如 一个学生的信息 一般有 名字 学号 成绩

这类由不同数据类型结合起来的集合可以由结构体表示

```c
#include<stdio.h>

struct student
{
    char name[20];
    int id;
    int score;
};

int main()
{
    struct student John={"John",17,85};
    struct student Lee={.id=10,.name="Lee",.score=89};
    printf("%s id:%d\n",John.name,John.id);
    printf("%s id:%d\n",Lee.name,Lee.id);
}
```

`struct`关键字表示结构体 用于定义一个结构体 注意 结尾有个`;`

在定义完类型后 可以使用`struct student`定义一个变量 

上例中分别使用了两种初始化 第一种需要一一对应 第二种可以指定初始化

注意 只有初始化才能写成如上两种形式 

赋值时不可使用 但可以这么写

`Jack=(struct student){"Jack",9,84};`

`=`右边的部分为一个`struct student`类型的临时变量 将他赋值给Jack

`struct`关键字必须出现在 `student`之前 不可省略 

但可以使用`typedef`来定义一个别名

`typedef struct student stu;`

这样 之后可以用`stu`来定义 

例如`stu Pikachu`

在访问结构体内部的变量是 使用`.`来指定具体的内容





# 基本数据类型

c语言的基本数据类型分为整型和浮点型 整型表示整数 浮点数用于近似表示小数

整型又分为有符号和无符号 有符号整型的类型大致如下

1. `signed char`
2. `short` 
3. `int`
4. `long`
5. `long long`

以上只有`char`前面必须加`signed`关键字才能表示有符号 其余不加默认为有符号

[虽然这很奇怪 但是标准并没有规定`char`是有符号还是无符号 不过大部分编译器都实现为有符号]

另外 `short` `long` `long long `三个关键字后面都可以加`int` 也可以省略不写 就像上面的表一样

例如 `long long int`

下面给出无符号整型 无符号整型前面必须有`unsigned`关键字

1. `unsigned char`
2. `unsigned short`
3. `unsigned int`
4. `unsigned long`
5. `unsigned long long`

尽量不使用无符号类型运算 如果对无符号数的规则不是很清楚 使用无符号数容易出错

在大部分情况下 应使用有符号数 [java语言没有无符号数 这不妨碍他是最受欢迎的语言之一]



为什么c语言使用这么多类型来表示整数呢 一个原因是机器运算时 都是固定位数的二进制运算 这有利于计算速度的提升 而c语言本省 就是对机器的简单抽象 基本上 c语言能做的事 和机器基本相同

这么多类型 表示的数值范围是不一样的 关于c语言标准的描述 这里不进行描述 因为c标准并没有具体规定数值的范围 甚至没有规定应该使用补码 反码或者是其他编码 [这部分内容参考计算机组成原理或者数字电路]

由于大部分机器都使用补码 所以这里直接给出常用的**数据模型**

```
Data Type     ILP32      ILP64     LP64      LLP64
char            8           8        8          8
short          16          16        16        16
int            32          64        32        32
long           32          64        64        32
long long      64          64        64        64
pointer        32          64        64        64
```

表格中给出的是各类型占用的二进制位数 pointer是指针类型

一般情况下 windows系统与linux系统32位编译器使用ILP32数据模型

如果是64位的编译器 那么windows使用LLP64模型 linux系统使用LP64模型

[编译器位数指的是编译器生成的可执行文件的位数 不是编译程序本身的位数]

**如果对二进制的数据表示不清楚 可查阅相关博客或资料**



为了解决无法确定类型长度的问题 c99标准提供了一个stdint.h头文件 使用该头文件 即可使用固定位数的数据类型

例如

```c
#include<stdio.h>
#include<stdint.h>

int main()
{
    int8_t x=100;
    int32_t y=-60;
    uint32_t z=65535;
    uint64_t w=1024;
}
```

`int`开头的为有符号数 `uint`开头的为无符号数 后面的数字只能取8 16 32 64



小数的表示有以下几种类型

1. `float`
2. `double`
3. `long double`

其中 `float`使用32位二进制表示 `double`使用64位二进制表示 `long double`由具体实现而定

一般来说 最常用的是`double`他的有效数字在15位左右[十进制下的有效数字]

`float`的有效数字较少 大概是6位左右 一般情况下 除非有存储限制 应使用`double`

`long double`基本上不使用 这里只做介绍

一个值得注意的问题是 浮点数是不精确的 例如

```c
int main()
{
    float x,y;
    x=123456789;
    y=123456788;
    printf("%f",x-y);
}
```

上例中 输出结果基本上不为正确的1 因为`float`的有效数字在6位左右 而上例中数字达到9位

如果使用`double`那么结果就没有问题 

由于这个特性 计算顺序有时候也会影响最后的计算结果 



运算过程中的数据类型与类型提升

不同数据类型之间运算时 有一定的规则

1. 不足`int`的 如`char` `short` 等 提升为`int` 
2. 不小于`int`且位数相同的有符号与无符号计算 有符号提升为无符号
3. 短的整型与长的整型计算 短的提升为长的
4. 整型与浮点型计算 整型会提升为浮点型
5. `float`与`double`计算 `float`提升为`double`

注意有符号向无符号转的问题 这也是无符号经常带来的问题 例如

```c
int main()
{
    int x=-1;
    unsigned int y=5;
    printf("%d",y>x);
}
```

正常情况下 y>x 是直觉上正确的 按c的规则 应返回一个非0值 然而 实际输出却是0 原因在于`int`会被提升为`unsigned int` 即-1的补码会被解释成无符号数 导致x被机器认为是一个很大的数



c语言还有一个基本类型 `void` 但他不能单独使用 必须作为复合类型的一部分或者是函数返回值



# 声明、定义与作用域

由于历史原因 c语言的一个名字[包括变量名 函数名 结构体名等]在使用前 必须在前面声明

一般情况下 定义了一个名字后 在后面即可使用它 即定义的时候会同时表示声明

定义表示的是从无到有地创建了一个名字 前面所有的例子中 都有大量的定义 例如 定义了一个int类型的变量 或者是定义一个函数 他与声明是不同的 声明并不创建新的名字





作用域是表示一个名字在哪里有效 出了作用域的范围 那么这个名字将不再有效

c语言分为**局部作用域**和**全局作用域** 

全局作用域是指定义在所有函数之外 所有结构体之外的变量 [形式上说 是没有在`{}`内部的变量]

局部作用域是指定义在函数内部的变量 [形式上说是定义在`{}`内部的变量]

文字说明不够直观 这里直接给出例子

```c
#include<stdio.h>

int x=10; //全局作用域

int main()
{
    printf("x=%d\n",x);
    int x=0; //局部变量隐藏全局变量
    printf("x=%d\n",x);
    {
        int x=20; //局部变量隐藏上一个局部变量
        printf("x=%d\n",x);
    }
}
```

`//`表示注释 只能注释一行 

`/**/`表示多行注释 注释范围从第一个`/*`开始 直到遇到第一个`*/`结束 注意并不允许嵌套

注释是在预处理阶段进行的 并不发生在编译期

作用域也不仅仅是由`{}`决定的 例如

```c
int fun(int x)
{
    int x=10; //wrong!
    return x+1;
}
```

上例会引发一个重名的编译错误 因为这两个x的作用域是相同的

另一个例子就是`for`

`for(int i=0;i<n;i++){}`中的`i`的作用域与`{}`内相同





定义变量时可以选择是否初始化 如果不进行初始化 局部变量和全局变量会有区别

全局变量会进行默认初始化[c语言中一般就是所有位为0] 局部变量则不进行任何操作

```c
int x; //默认初始化 值为0

void fun()
{
    int x; //不初始化 值不确定
    int y=20; //指定初始化 值为20
}
```



以上结果似乎并没有显示出声明有什么用处 因为定义的时候即已经声明了 下面给出必须使用声明的例子

```c
#include<stdio.h>

extern int add(int x,int y); //声明有add()这个函数

int main()
{
    int x=add(10,20);
    printf("%d",x);
}

int add(int x,int y)
{
    return x+y;
}
```

在main函数中 使用了add()函数 但此时add并没有定义 所有在此之前 必须说明有这个函数

`extern`关键字表示外部的 他可以引用其他文件中的全局变量 

对函数的声明`extern`关键字是可以省略的 但对全局变量的声明 他是不可省略的 否则会被当成是定义变量 从而导致重名错误

[这里提一下 c语言有个历史问题 如果一个函数在使用前没有定义或声明 那么编译器会自动生成一个声明形式为`int function_name()`的声明 所以上例其实是可以编译通过的 但会有警告 不过 不是所有的函数的形式都是如此 如果对应不上 会引发一些程序正确性的错误 `()`内空表示可以接受任意个参数 这也是一个比较容易出错的问题]



变量和函数的声明与定义还可以添加一些修饰前缀

例如 需要使用一个不能被修改的量 使用`const`修饰 `const`原来是常量的意思 但在c语言中准确地说他是**只读[即 read-only]** 

```c
#include<stdio.h>

int add(const int x,const int y)
{
    x=10; //wrong
    return x+y;
}

int main()
{
    const int x=100;
    int z=add(x,20);
    printf("%d",x);
}
```

`const` 更多地是用在指针类型上 后序再介绍 不过定义一个全局的const变量还是很有用的





# 运算符与求值顺序

c语言提供了一些运算符 包括算数运算符 判断运算符 逻辑运算符 位运算符 赋值运算符等

首先说明算数运算符 有 + - * / % ++ -- 分别是加 减 乘 除 求模 自增 自减

其中++ --又分为前加和后加 这里直接给出例程

```c
int main()
{
    int x=1,y=2;
    int a=x+y; //a=3
    int b=x-y; //b=-1
    int c=x+x*y; //c=3
    int d=x/y; //d=0 注意 整数除以整数还是整数 向0取整
    int e=x%y; //e=1 在c99标准中 相当于取余数 只能对整型使用
    int xx=x++; //x自增1 并返回原值1 即xx=1
    int yy=++y; //y自增1 并返回增加后的值 即yy=3
}
```

其中乘法 除法 求模 优先级高于加法和减法 

++ --由于会改变自身的值 优先级高于乘除和求模 



判断运算符 用于处理逻辑条件 

```
>  大于
<  小于
>= 大于等于
<= 小于等于
== 等于
!= 不等于
```

如果条件成立 那么他们会返回非0值[代表真] 否则 返回0值[代码假]

这些运算符**一次只能处理两个操作数** 不能像数学上的a>b>c 

为了处理这类情况 可以使用逻辑运算符

```
&& 并
|| 或
!  条件取反
```

例如 a>b>c 应写成`a>b && b>c`

如果是a>b或者c>b 应写成 `a>b || c>b`

在使用条件语句和循环语句时经常会用到这两个运算符

!用于逻辑取反 例如 a==b的相反事件是 `!(a==b)` 括号不能去掉 因为!的优先级很高 [这里直接用`!=`更好]





关于运算符的使用 这里不做过多的描述 自行搜索相关内容 

这里主要描述的是更重要的**运算符优先级与结合性**

对优先级的理解 与数学中相似 如 *的优先级高于+  

而结合性主要是相同优先级的运算符那个先处理的问题 类似与1+2-3是先算加法还是减法 并没有意义 因为结果相同

结合性主要是给一元运算符使用 例如++ 

这里先提一个指针的例子 

```c
#include<stdio.h>

int main()
{
    int *p;
    int a[2]={0,1};
    p=&a[0];
    printf("%d",*p++);
}
```

指针可以进行算术加减[只能加减 不能乘除] 表示他指向位置的左右偏移

这里 指针p指向a[0] `*p++` 中`*` 代表解引用 且他的优先级和++相同

这里就是一个相同优先级该先与哪个运算符结合的问题 单目运算符均从右至左结合 即先++ 再*

由于后置的++返回原值 即还是a[0]的地址 故解引用后访问到的值就是a[0]的值



### 求值顺序

诸如`int x=(a+b)*(c+d);` 直观上讲 肯定是先求a+b 再求 c+d 然而c语言并没有规定求值顺序

编译器可以自由地选择先算哪一部分 因为上例先算哪个结果都相同 这也不破坏优先级和结合性

但是 如果是带有副作用的表达式 就会产生问题

例如 `int x=(a+b)*(++a);` 显然 先算左边和先算右边 求得的结果不同 但c语言没有规定到底先算哪边 所以 该表达式是一个未定义行为[undefined behaviour] 结果不确定

这类带有副作用的表达式 应尽量避免

另外 在一条语句中[即一个`;`] 函数调用顺序也是不确定的 例如`int x=f(1)+f(2);`

为了保证结果正确 函数f()返回的结果应与调用次序无关



###赋值运算符

赋值运算符`=` 虽然与初始化时的等号相同 但二者是不同的

另外 为了方便 c语言还提供`+=`之类的运算符 例如`x+=a+b;` 他与`x=x+(a+b)`相同

关于赋值问题 这里还有一个未定义行为 即一条语句中 不能对同一个变量同时赋值两次以上

例如`x=x++;`由于++会修改x的值 相当于赋值 这里同时赋值两次 结果是不确定的 

另外一个经典的问题 

```c
#include<stdio.h>

int main()
{
    int i=5;
    int x=(i++)+(i++)+(i++);
    printf("%d",x);
}
```

这里对i同时赋值了3次 其结果也是不确定的 较新的编译器 如gcc7.2 会对此类错误警告[但不报错]



最后附上c语言运算符的优先级与结合性表 越靠前的运算符优先级越高 相同行的运算符优先级相同

![operator](https://github.com/YohnWang/let-s-study/blob/master/resource/picture/c-operators.png)



# 语句

c语言提供选择语句 循环语句 和跳转语句

选择语句包括

1. if语句
2. switch语句

循环语句包括

1. while语句
2. for语句
3. do while语句

跳转语句使用`goto` 



选择语句例程

```c
void fun(int a,int b)
{
    if(a==b)
    {
        a=1;
        b=2;
    }
    else 
    {
        a=2;
        b=1;
    }
}
```

另外一个是switch语句 

```c
void f(int x)
{
    switch(x)
    {
    case 1:
        printf("first");
        break;
    case 2:
        printf("second");
        break;
    case 3:
        printf("third");
    default:
        printf("default");
    }
}
```

如果x匹配到某个值 那么就会跳转到那个位置去执行 `break`表示结束switch语句 否则 不管有没有匹配 都会继续向下执行 知道switch语句结束或者是遇到下一个`break`

switch不能范围匹配 他只能匹配一个确定的值 并且必须是整型类型 



循环语句例程

之前以有for语句和while的例程 这里不再给出 

do while 语句与上述两个循环不同的是 他至少执行一次

```c
void fun(int a,int b)
{
    do
    {
        printf("a-b=%d\n",a-b);
    }while(a>b);
}
```

由于该语句第一次循环时不进行条件检查 实际使用中是容易发生问题的 故不推荐使用do while语句



`break`与`continue`关键字

在循环中 可能需要用到某一条件达成后立即结束循环 或者是某一条件成立时 直接进行下一次循环

```c
void fun(int a,int b)
{
    while(a<b)
    {
        if(a+b==10)
            break;
        if(a==10)
            continue;
        printf("process once\n");
    }
}
```

`break`执行后会直接结束循环 [只能退出一重循环]

`continue`执行后会立即回到循环的条件判断位置 然后开始下一轮循环

此处如果`a+b==10`成立 那么循环结束 

如果`a==10`成立 那么下面的`printf`将不会执行 但循环继续

由于`break`和`continue`会破坏执行结构 所以应尽量避免使用 尤其是`continue`



`goto`语句

跳转语句会直接跳转到指定的位置执行[限制在一个函数内 不能在函数间跳转]

由于其任意性 一般是不会使用的 常用的地方一般是错误处理或者是多重循环退出

考虑以下问题 是否存在某个三位的数 abc 他等于a^3+b^3+c^3 [`^`这里代表幂 c语言中他是**异或**]

只要找到一个就行

```c
int main()
{
    int result=-1;
    for(int i=1;i<10;i++)
    {
        for(int j=0;j<10;j++)
        {
            for(int k=0;k<10;k++)
            {
                if(i*i*i+j*j*j+k*k*k==i*100+j*10+k)
                {
                    result=i*100+j*10+k;
                    goto END;
                }
            }
        }
    }
END:
    printf("%d",result);
}
```

此处的三重循环 使用`break`是不能跳出的 使用`goto`则很方便

另一个作用是错误处理 方便统一管理

无论何种使用方式 `goto`都是往后跳转 如果往前跳转 会导致程序逻辑混乱 

一般情况下 避免使用`goto` 





# 指针与数组

指针和数组都是对内存资源的一种使用 二者相似又有区别 要理解指针与数组 就需要理解资源是如何存储在内存上的

典型的内存一般是每个字节[8个bit]都有一个唯一的地址例如

| 地址 | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 内容 | 10   | 20   | 17   | 32   | 78   | 255  | 0    |

现有一个指针`int8_t *p=3;` 则p的值为3 他存储的是一个地址 在解引用时 *p 可以获取到3号地址中的内容 即32

以上只是指针的一个简单例子 但运行在操作系统之上的程序 内存由操作系统管理 程序是无法直接获取真实的物理地址 而且资源由操作系统管理 使用内存必须向操作系统申请 否则访问的既是非法地址 操作系统会终止程序 并报告段错误

除了指针要指向合法地址外 还必须指明被指向的对象的类型 例如 上例中 被指向的对象的类型是`int8_t`

### void指针

c语言提供一个通用的指针 他可以指向任意类型 也可以被赋值给指向任意类型的指针 例如

```c
#include<stdio.h>

int main()
{
    int a=10;
    void *ptr_void=&a;
    int *ptr_int=ptr_void;
    printf("value is %d,address is %p",*ptr_int,ptr_int);
}
```

`void*` 只能指向对象 他不能解引用 因为他丢失了被指向对象的类型 必须重新使用另一个指针来赋予被指向对象的类型

`%p`用于输出地址信息 

在c++中 `void*`代表的是空指针 而c语言中 他代表的是通用指针 这也是c和c++不兼容的一个地方

上述代码使用c++编译器编译 会引起一个类型不一致的编译错误



### 使用指针指向申请的内存

在函数上的变量 存储在一个叫做栈的地方 他在函数调用结束后会被释放 此时再访问他是非法的 并且 栈的容量是有限的 一般地 windows程序的栈空间是2MiB 而linux的栈空间一般是8MiB 

[MB MiB的区别自行查阅]

为了长时间使用一块内存 需要申请内存 被申请的内存存储在堆上 他的生命周期不收函数调用的影响 知道程序员手动释放为止

下面看一个例子

```c
#include<stdio.h>
#include<stdlib.h>

int* fun()
{
    int a=100;
    int *p=malloc(sizeof(int));
    double *q=malloc(sizeof(*q));
    *p=200;
    *q=10.24;
    printf("%f\n",*q);
    free(q);
    return p;
}

int main()
{
    int *p=fun();
    printf("%d",*p);
    free(p);
}
```

`malloc`函数用于申请内存 并返回该内存块的首地址 他接受一个内存块大小的参数[即指明需要多少字节内存] 

`sizeof`运算符 [虽然他很像一个函数 但是他是运算符] 用于计算类型的占用内存的字节数 或者计算指定对象占用的内存字节数[二者其实是一样的 `sizeof`通过推导被指定对象的类型来计算字节数 上例中`*q`的类型是`double`]

被申请的内存块不会自动释放 需要使用`free`函数释放 注意 `free`函数的参数必须是申请内存的首地址 而且 被释放后就不能再次释放 否则会引发错误 

`malloc`和`free`函数需要包含头文件`stdlib.h`才可使用

一般情况下 申请内存使用最多的地方会涉及结构体和数组





指向`const`类型的指针

指针可以指向`const`类型 例如

```c
int fun()
{
    int x=1024;
    const int *p=&x;
    *p=10; //wrong!
    printf("%d",*p);
}
```

如果`p`指向`const int` 那么一点问题都没有 因为类型描述是一致的

但是 用`const` 修饰被指向对象的类型的指针 可以指向不被其修饰的对象

因为x是可以修改的 用一个不能被指针修改的类型没有什么问题 这样可以防止误修改

上述的`*p=10`是错误的 因为`*p`的类型是`const int` 他是不可修改的

这在函数参数传递过程中更为有效 例如 

```c
#include<stdio.h>

struct stu
{
    char name[20];
    int  id;
};

void print_stu(const struct stu *s)
{
    printf("%s , id: %d\n",s->name,s->id);
}

int main()
{
    struct stu Jack={"Jack",21};
    print_stu(&Jack);
}
```

对于打印函数 是绝对不会修改对象信息的 `const` 关键字可以防止这种事情的发生

这类指针也被称为**常量指针** 他是个指针 被指向的对象是常量[相当于控制指针访问权限]



不可修改的指针

指针本身也是一个对象 他存储在内存上 同样 他也可以像基本类型一样 添加`const` 以防止其被修改[指针本身的值不被修改 而指向的对象是否可以修改 需要上述的`const`]



```c
int main()
{
    int x=10,y=20;
    int *const p=&x;
    p=&y; //wrong!
    printf("%d",*p);
}
```

上述的`p`本身就是一个常量 他需要初始化 一旦初始化后就不能被修改 但他可以修改被指向对象 因为被指向对象的类型是`int` 可以被修改 

这个指针通常被称为**指针常量** 他是一个常量 并且是个指针

当然 也可以构造一个常量指针常量 `const int *const p=&x;`

另外 `*`与`const`不必紧挨在一起 中间也可以用空格分离 如 `int * const p=&x;`



### 数组

